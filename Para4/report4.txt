--------------------------

学籍番号 : 1613354
氏名 : 星野シンジ

--------------------------

回答1 :
1.1) 途中結果が表示されなかった理由の説明

writeState()は、"="ボタンを押した時にoperation()メソッドの中で呼び出される
ので、JavaFX Application Thread上で呼び出されている。また、operation()メソッドは、
synchronizedで同期が取られているので、途中でスレッドに他から割り込むことができない。

writeState()メソッド内の、label.setText()メソッドは、labelのプロパティtextの
値を設定するものであり、新しく設定されたテキストの描画はJavaFX Application Thread上で実行される。
従って、"="ボタンを押したイベントの処理が全て終わるまでこれは実行されない。このことにより、
outputのラベルのテキストを変更する処理が全て遅れて行われることになる。

1.2) 改良方針の説明

Executor2クラスのoperationメソッドがJavaFX Application Threadから呼ばれないようにし、
"="ボタンが押された時のイベントハンドラの処理がoperation()を待たずに即座に返るようにする。
そのようにすれば、setTextでoutputラベルの表示が変えられると、JavaFX Application Thread
によって即座に画面に変更が適用されるようになる。

そのために、operation()は新たに生成されたスレッド上で動かすようにした。
また、"="ボタンを計算途中で連打したりした際に、出力が意図していないものにならないように、
operation()の処理を行っているスレッドが生きている時に、"="ボタンを押しても無視されるようにした。

ちなみに、JavaFX Application Threadを"="ボタンのイベント処理にとらわれないようにすることによって、
同時に計算中のユーザー入力もできるようになった。ただし、計算中は"="ボタンは押しても無視される。

1.3) 発生したエラー文は次のとおり

Exception in thread "Thread-5" java.lang.IllegalStateException: Not on FX application thread; currentThread = Thread-5

runLater()の処理内容について

引数で与えられたRunnableを将来のある時間にJavaFX Application Thread上で実行する。

runLater()がjavafxに用意されている理由

setTextなどのUIエレメントの変更は、JavaFx Application Thread上でないとできない。
従って、JavaFX Application Thread以外のスレッドでUIの変更を行いたい時にrunLater()
がなければ困る。よって、javafxにrunLater()が用意されている。

回答2 :
2.2)2つのスレッドのそれぞれの処理内容について
1つ目のスレッド

Main07.javaのinit()メソッド内で走らされているスレッド

ShapeManagerの配列smsに含まれているShapeManagerの内容を
定期的にtargetに対して、drawし、まとめてflushしている。つまり、
ShapeManager[] smsの内容の描画を行なっている。

2つ目のスレッド

Main07内のmainスレッド

Main07のインスタンスを作り、初期化を行う。
初期化を全て行った後は、新たな通信を待ち受けるためのスレッド
としての役割を持つ。具体的には、Main07クラスのstart()メソッド
のループを処理している。


2.3)同期についての考えられている配慮

配慮は十分である

十分であると考える場合のその理由

2.2で挙げた二つのスレッド間で共有されているデータはShapeManagerの配列smsだけであるが、
smsはfinalなので、インスタンス自体は不可変であり、また、smsのメソッドは同期が取られているので、
並列計算をしても安全である。

不十分であると考える場合の問題となる具体的状況

2.4)並行サーバを実現するにあたり工夫した点
各クライアントからのデータの表示位置の割り振りについてどのように実現したかなど

並行サーバをExecutor.newFixedThreadPoolメソッドを用いて実装した。
これにより、サーバの接続を管理するスレッドはMAXCONNECTIONに制限され、それ以上の
接続がやって来ると、後から接続したクライアントは待たされる。

接続していたクライアントがどの順序で接続を切っても、待たされているクライアントが
空いた接続スロットに入ることができるように、boolean型の配列を用意し、
それぞれの接続の状態を保存するようにした。
これにより、接続の際に使用される画面のスペースは必ず空いているところが使用されるように
なった。

回答3 :
3.1)改造方針、スレッドの役割分担についての説明

各ソケットに接続が繋がった際に、そのソケットにTextTargetでShapeManagerのデータを送る用意をする。
これは、communicate()メソッドが呼ばれてセッションが確立された時の行う。

別のスレッドで、接続があるソケットに対し、TextTargetに全てのShapeManagerの
内容をdraw()し、flush()することによって、クライアントにサーバの画面のデータを送り返している。

ブロードキャストの処理は、サーバの画面の処理画面と同じスレッド内で行ったので、並列計算の安全性について
の変化はない。

回答4 :
4.1)
PrintStreamでの例外発生を確認する方法

PrintStreamは例外的な状況になった時にIOExceptionをスローせず、内部フラグの設定
が行われるだけである。

よって、PrintStreamの例外発生を確認したければ、checkError()メソッドを用いて、
その内部フラグの状態を確認すれば良い。

例外処理がPrintStreamと他のStreamとで異なる理由

PrintStreamは例外的な状況になった時にExceptionをスローするのではなく、
内部フラグの変更だけを行うという仕様になっていることから、例外処理の
手法が他のStreamと異なる。

ちなみに、OutputStreamの場合の例外処理は、IOExceptionをキャッチすれば良い。

4.2)
受信機能の追加について、工夫した点があれば記述

ブロードキャストのデータを初めは、サーバ側の画面のsnapshotを撮ったものの画像データを送る
仕様にしていたが、この実装だと処理が多すぎて動作しなかった。

そこで、ShapeManagerのデータを遅れば、処理を減らせると思ったので、TextTargetにShapeManager
でdrawをし、それで送られたデータをMain08側でMainParserを用いて解釈し、描画するという実装にした。

今回の課題で特に学べたと感じたこと

今回のブロードキャストをするサーバの実装によって、自作のグループビデオ電話プログラムが作れる
ような気がした。
