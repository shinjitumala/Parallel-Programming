--------------------------

学籍番号 : 1613354
氏名 :  星野シンジ

--------------------------

回答1 :
1.1) 空欄に入る数は以下のとおり

A： 256^3 = 16777216

B: 4^3 = 64

C: 4^3 = 64

1.2)
並列化で問題となるStreamの処理の番号

1番目のストリーム

1.3)単純に並列化したのでは結果が異なる原因

RGBクラスのメソッドは同期が取られていない。
ここで、１番目のストリームを並列処理すると
同じRGBオブジェクトに対して同時にaddメソッドを呼び出してしまう可能性があり、
RGBオブジェクトのメンバ変数に間違った値が入る恐れがある。
従って、並列計算をしていない時と結果が異なる。

(しかし、実際にはサンプル数が多く、それの平均を取っているので、
いくつかの色のデータがおかしくなったぐらいでは、
目にわかるほどの色のズレは現れないことが多い。)

1.4)並列化に対応するために行った変更点

まず、２、３番目のストリームはそのままparallel()メソッドを
用いて、並列化を行なった。
次に、１番目のストリームをparallel()メソッドを用いて並列化を行うが、
結果が変わることのないように、RGBクラスのadd()メソッドにsynchronized
をつけることによって、同期を取り、並列計算をしても安全になるように変更した。

runLater()がjavafxに用意されている理由

??



回答2 :
2.1)
出力される時間の意味

100単位時間分の玉の運動の計算にかかった時間。

達成された高速化の数値的説明

計測の結果得られたデータは次の通り

PARAMETER=  SINGLE      PARALLEL
test1       49716msec   30798msec
test2       49563msec   31152msec
test3       48375msec   30496msec

このデータにより、玉の運動の計算速度が
並列処理のより50%ほど速くなったことがわかる。

計測時間の信頼性を向上させるために行った工夫、計測で注意した点

計測の結果が偶然現れた値でないことを
保証するために並列計算をしているときとしていない時それぞれで
複数回の計測を行い、交互に計測を行った。

Main11が同時に起動している他のプログラムに計算資源を奪われないように
実験を行う前に、ターミナル以外の全てのプログラムを閉じた。

2.2)
衝突判定部分の高速化についてのjvisualvmを使用した調査方法の説明

まず、jvisualvmはサンプラでサンプリング開始ボタンを押さないとサンプリングが始まらないので、
Main11のmainメソッドの頭にSleep(10000)を挿入。さらに、最後までサンプリングが正しくできるように
start()メソッド内のSystem.exit(1)の前にSleep(5000)を挿入

次に、Main11をSINGLEとPARALLELのパラメータを与えて、一つずつ実行する。
それぞれを実行する際にSleep(10000)が終わらないように、できるだけ速く
サンプル開始ボタンを押し、プログラムの最初から最後までサンプリングする。

最後に、para.graphic.shape.CollisionCheckerParallel2.check()のセルフ・タイム
を比較する。

ここで、セルフ・タイムは実行するのにかかった時間で、セルフ・タイム(CPU)は
実行していた時間のうち、実際にCPUを使用していた時間である。コードの一部分の
実行時間が知りたいのでセルフ・タイム（CPU)を採用した。

調査により判明した衝突判定部分の高速化前後の処理速度の比率

para.graphic.shape.CollisionCheckerParallel2.check()のセルフ・タイム(CPU)

並列処理化前：38,970ms
並列処理化後：10,872ms

となり、並列化により処理時間が75%程度削減できていることがわかった。

2.3)
発見された改善対象のコード部分

jvisualvmのサンプリングの結果を見ると、
para.graphic.shape.ShapeManager.remove()
para.Main11.main()
の二つもCPUをたくさん使っていることがわかったので、それらで改善できるところがないかを
考えた。

まず、ShapeManagerクラスのremove()メソッドは、変更できそうな点が見つからないので、
改善する部分の候補として除外した。

次に、Main11のstart()メソッドの中にある２つのwhile文に注目して見た。
一つ目のwhile文の中で、jというint型の無意味な変数が宣言されており、さらにjについて無意味な計算も行われている。
また、一つ目のwhile文の中でもう一つのwhile文があり、ここで２つのShapeManagerについての当たり判定をこなっている。
ここでは、二つ同時に当たり判定を行なっているが、もう少し改善できそうだと考えられた。

改良方針

int型変数jの宣言とその無意味な計算についての行を削除した。

当たり判定の計算を行うコードを見て見ると、後半の部分で結局
四角との当たり判定の方が、壁との当たり判定より優先される
ようにコードが書かれている。よって、２つのShapeManagerに対する
当たり判定を同時には行わず、先に四角との当たり判定を確認し、
もし当たっていなかったら、壁との当たり判定を確認した方が
効率が良くなると考えた。これにより、check()メソッドの呼び出し回数が
減ると考えた。


2.4)2.3で行った改良部分の改良前後の処理時間について

改良後
  SINGLE
    Thread-3:
  PARALLEL
    main(): 7,592ms
    check(): 10,476ms

処理時間の定義




改良前と比べ改良後の処理時間は　　　　％となった



回答3 :
3.1)ゲーム性を高めるための実装
得点ルールの定義




得点計算のコード部分について




得点表示のためのコード部分について




ゲームの終了条件の定義




ゲームの終了判定のコード部分について





スタートボタンを押した際の新たな初期化処理について






ゲームの難易度の方針





数値選択とゲーム難易度についての実装部分について






3.2)さらなるゲーム性を高めるための実装
実装方針




実装箇所







今回の課題で特に学べたと感じたこと
