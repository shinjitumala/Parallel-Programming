--------------------------

学籍番号 : 1613354
氏名 : 星野シンジ

--------------------------

回答3 :
3.1) ２つ目のソケット接続が開始した後で、それぞれのゲームが開始される
ようにした変更箇所の説明

  GameServerFrameクラスでprivateのint型変数usersで現在サーバに接続している
  クライアントの数を保存している。しかし、この変数の実装は少し不十分で
  現在接続しているクライアントの数＋１の数字を持っている。
  よって、usersにインクリメントをかけるタイミングをaccept()
  した後にすることによって、正しい値をusersに持たせることができた。
  さらに、usersはプライベート変数なので、それの値をGameServer01で取得する
  ためにgetUserCount()というメソッドを実装した。

  GameServer01本体では、usersがMAXCONNECTIONに等しい時だけ
  ゲームの演算が行われるようにした。これはつまり、二人接続している状態
  でなければ、ゲームが進まないことになる。

3.2)
ゲームの終了条件
（3.4と合わせて回答したい場合は、「3.4)の回答を参照」と記すこと)

  3.4)の回答を参照

実装方針
  GameServer01でgameover()というprivateメソッドを実装し、
  それが呼ばれると、クライアントが全員接続を切られるようにする。

ソースコード中の実装部分
  ゲームの終了条件が満たされた時に、gameover()が呼ばれるようにした。
  ゲームの終了条件の確認はcalcForOneUserメソッド内でブロックが破壊されるごとに
  行われている。

3.3)
空欄A: thread (Thread型)
空欄B: UserInput
空欄C: thread2

スレッドセーフである
スレッドセーフであると考える理由
  変数threadにはvolatile修飾がついているので、
  現在の値に依存する代入が行われず、かつ複数の
  スレッドから書き込みが行われないならば
  スレッドセーフである。

  今回の場合、thread2でinterrupt()メソッドが呼ばれる時に
  threadを参照しており、一方でUserInputスレッドでは
  threadがInterruptedExceptionを投げた時に、threadに
  nullを代入している。よって、スレッドセーフである。

  他にも、  gamestart()メソッドが呼ばれた時に、
  スレッドを新しく作り、threadに代入されるが、
  これはthreadがnullでない限りはこれは実行されない。
  つまり、同期が取られているのでここも問題ない。

問題が生じる状況





3.4)
対戦ゲームのルール説明
（利用者に説明する遊び方）
  ブロックを連続で破壊すればするほど、スコアが
  高くなるゲームである。
  ボールを落とすと、コンボ数はリセットされ、減点もされる。

  高いコンボ数を得るために、緑色のパワーアップブロックが
  ところどころに生成される。それを破壊すると、ボールが
  一定時間ブロックを貫通して破壊できるので、うまく利用せよ。

  相手のコンボを邪魔するために、青色の妨害ブロックが
  稀に生成される。それを破壊すると相手のボールが一定時間透明になり、
  コンボを失ってしまうことであろう。

  ゲームは、どちらかのプレイヤーがブロックを全て破壊するか、
  点差が256点以上になるとゲームは終了し、その時点で
  点数が高い方が勝者となる。

  また、スライダの値を変えるとバーの幅が変わる。これは、
  プレイヤーで別々に設定できるので、実力に差がある時は
  これを用いると良い。

ゲーム性を高めるためにルールで工夫した点
  ゲーム中負けている方のカメラには、減色処理を行い、
  点差が大きいほど減色される。

  Para5のGame03の貫通パワーアップをこちらでも実装した。
  パワーアップブロックを破壊すると、
  一定時間ボールがブロックを貫通できるというものである。

  パワーアアップブロックに加え、対戦ゲームなので
  相手を妨害する妨害ブロックも存在し、
  それを破壊すると、一定時間相手のボールが
  見えなくなる。これで、相手の長いコンボを邪魔できる。

  ボールを落とすと、点数をペナルティとして減点され、
  パワーアップ状態及び、コンボはリセットされる。

  したがって、このゲームのゴールは如何に相手に邪魔されずに
  長いコンボを続けるかである。

  また、スライダの値を変えるとバーの幅が変わり、難易度も変わる。

ルールを実現するためにどう実装したかを説明
  まず、ゲームで負けている方が減色されることの実装は、
  Game04でイメージのフィルタとして、Filter8を利用するように変更した。
  その上で、GameServer01側でクライアントのgamerstateをスコアの点差
  の基づいて設定することによって、負けている側が減色されるように実装した。

  パワーアップ及び妨害ブロックの実装はPara5のGame03と全く同じである。
  ブロックの種類ごとに別々のShapeManagerを用意し、当たり判定の部分で
  処理を分けることができるようにする。そうすることによって、
  パワーアップや妨害ブロックを破壊したことを感知でき、
  それに基づいて一定時間効果を与えるように実装した。

  ボールを落とした時はdeath()メソッドを呼び出し、そのすぐ後に
  reset()メソッドを呼び出すように実装した。
  death()メソッドは、スコアに対するペナルティ及び、コンボ、パワーアップ等
  のリセットを行なっている。
  reset()メソッドは、ゲームの初めにも呼び出される関数であり、
  ボールの初期速度の横成分をランダムに設定している。
  このようにすることによって、ゲーム中ずっとボールの横軸の
  速度が変わらないことにより、ブロックを全て破壊しきれないことが
  ないようにした。

ゲーム画面の改良点など、配布プログラムから改良した点
  スコアが人の顔の上にあると見えにくいので、
  スコアの数を少し下に移動させた。

  コンボの数が見やすいように、ボールが当たった時に
  そこにコンボ数が表示されるようにした。
  また、コンボが多ければ多いほど数字が大きくなるので
  隣のプレイヤーの画面をじっと見ずに相手がどれぐらい
  コンボしているかが感じ取れるようになった。

  ボールを落とすとよくないことが、感覚的に伝わるように
  地面の色を赤にした。

3.5)
勝敗決定規則の説明
  どちらかのプレイヤーの点差が256以上になるか、
  どちらかのプレイヤーがブロックを全て破壊するかで
  ゲームは終了し、スコアが大きい方が勝ちとなる。

勝敗決定規則の実装法の説明
  はじめにブロックの数を数え、ブロックが破壊されるたびに
  ブロックの数にデクリメントをかける。
  どちらかのプレイヤーの残りブロック数が０になればゲーム終了。
  また、ブロックが破壊されるたびに、スコアのさも計算し、
  256以上であればゲーム終了。

  ゲームが終了した時点で、スコアの大小を比較し、
  勝者を決定する。

3.6)
敗北案を表現するための画像加工フィルタの設計意図の説明
（どのように敗北感を演出するか）
  減色フィルタをかけることによって、負けている方が
  色が少なく気持ち悪い映像になる。

フィルタの実装法の説明
（技術的に、どのような演算を行ったかを説明）
  フィルタ自体の処理としてはFilter8そのままである。
  具体的には、使いたい色の数だけサンプルの色を用意し、
  入力で与えられた画像の各画素を最も近いサンプルの色に
  置き換えて出力する。

実装部分についての説明
(どのファイルのどの部分を変更して、ゲーム終了時の勝敗に従い、敗者側のカメラ
にのみ画像加工を施すよう実装したかを解説)
  ゲームが終了した時に、ゲームの進行だけを止めて
  画像等の処理は続けるようにしないと、カメラの敗北感をゲーム終了後
  に表現できない。
  よって、ゲームが進行するか否かを表すboolean変数を用意し、
  gameover()が呼び出されるとその変数(game)をfalseにしゲームの進行が止められる。。
  それと同時に、gameover()内以外でのgamerstateの更新も止められる。
  さらに、敗北者に対してだけgamerstateメソッドでフィルタのスライダの
  値を変更され、敗北感が出るようにする。
  しかし、この変更が適用されるまでは少し時間がかかるので、
  ゲームが終了してから一定時間後にクライアントとの接続を切るように
  実装しなければならない。
  そこで、gameover()が呼び出されると新しいスレッドが
  生成され、そこで5秒間待機した後に、接続を切るように実装した。
  こうすることによって、敗北者だけ黒になる直前まで減色された
  映像になり、顔が８色で表現されるようになる。

3.7)
録画したファイル名とおよその再生時間
  録画した動画はgame1613354.mp4というファイル名で保存した。
  録画の再生時間は１分１２秒である。

------
来年度に向けた講義演習についての質問

講義・演習課題全体で一番記憶に残っている事柄は
  もぐらたたきのゲームでもぐらを作るのを頑張ったこと。
  並列処理を学んでから家でC＋＋の並列処理にチャレンジしたこと。

演習で一番大変だった課題は何回目の何番目ですか
  第7回の3番目

演習で一番将来役立ちそうだと思った課題は何回目の何番目ですか
  第7回の3番目

今この講義演習に関連してより詳しく知りたいと思うこと（何点でも）
  並列処理の実装における原則のようなもの。
  並列処理プログラミングにおけるフィロソフィーのようなものを知りたい。
  オブジェクト指向プログラミングにおけるクラスの分け方の原則と同じようなもの。

お疲れ様でした。
