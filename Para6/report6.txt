--------------------------

学籍番号 : 16B13354
氏名 : 星野シンジ

--------------------------

回答1 :
1.1) if文を使う代わりに取った方法について

  if文を使うことにより、条件分岐が現れるのを避けるために、
  論理演算を用いた。
  例えば、変数aをみて、変数maxより大きければ、aをmax
  に代入するという処理
  がしたい時は
  max = (a > max) * a + (max >= a) * max;
  という計算でmaxの値を更新できる。

回答3 :
3.1)
barrier(CLK_LOCAL_MEM_FENCE)の挿入箇所とその必要な理由

  ワークグループ内でローカルメモリ処理の同期を取っている箇所は二つある。

  一つ目は、入力から画像データをローカルメモリにコピーをする処理の直後である。
  これは、コピーが終わっていないのに
  いつ入れられたかわからないメモリのデータを用いて計算を勝手に始めることを
  防ぐためである。

  二つ目は、ワークグループ内で色の和を計算している時に、他のワークアイテムの
  ブロックの計算が終わるのを待ってから、次に大きいブロックの計算に移るために
  かけられているメモリバリアである。

3.2)
1ワークグループに属するワークアイテム数

  ワークグループの大きさが4x4であるので、一つのワークグループの中には合計で１６個の
  ワークアイテムがある。

回答4 :
4.2)
スレッドセーフではないために生じたことが明瞭にわかる映像を作るにあたっ
て意図した点
（どうすれば誤った静止画像が頻発するか、どのような模様ならば誤りが明瞭か）

  まだ並列処理のバグの原因がわからない状態で探したので、
  経験則のような方法でバグがわかりやすいような画像を取ってきた。

  録画を２０秒ほどやると、スライドを触る触らないに関わらず、
  壊れた静止画像が複数入った録画ファイルが含まれる。
  しかし、スライダーを動かすと、壊れやすくなる。

  静止画像が壊れる時は、横に線が入り、前の時間のフレームが
  現在のフレームに残って録画される現象が起きる。

  以上のことから、壊れた静止画像が壊れているのが明瞭にわかるのは
  映像で何かが高速で横に動いている時だと考えた。
  従って、Main13の横に動く丸のコードを参考にして、
  縦に長い長方形を横に動かせば、静止画像が壊れた時に
  はっきりとわかると思い、それを実装した。

4.3)
録画機能がスレッドセーフでない原因

  TargetRecoder.java内で定義されているTimerTaskを継承する
  Shotクラスのrunメソッド内でTargetのgetImage()メソッド
  を用いている。

  ところが、getImage()メソッドはJavaFXCanvasTargetクラスのメンバ変数であるimageを
  参照渡しで返しているため、Shotクラスのrun()でimageを動画の１フレームにしている途中に
  JavaFxCanvasTargetのflush()メソッドが割り込んで、結果として動画では
  別々の時間で描画された画像が混ざって静止画像にされてしまう。

  ここで、画像は基本的に左上から描画されるが、壊れた静止画像で
  下の部分の方が時間的に先のフレームであることから、
  Shotクラスのrun()メソッドの実行中に
  JavaFXCanvasTargetのflush()に割り込まれて
  静止画像が壊れているとわかった。

  従って、スレッドセーフでない原因は、JavaFXCanvasTargetのimageという
  メンバ変数を複数のスレッドで正しい同期を取らずに共有しているところにある
  という結論になった。

スレッドセーフとするための改良方針

  複数のスレッド間で同じデータを共有しないという方針で考えて、
  getImage()のメソッドを呼び出す代わりに、何らか別の方法で
  JavaFXCanvasTargetのimageのコピーを作業用として
  持ってくることにした。

スレッドセーフとするためのソースコードの修正部分

  JavaFXCanvasTargetのメソッドでcopyImage()という
  メソッドがあり、コピーの途中もちゃんと同期が取られているので、
  getImage()メソッドの代わりにそれを用いれば解決した。

今回の課題で特に学べたと感じたこと

  人のコードを読んで理解する練習になった。つまり、
  プロフェッショナルとしての仕事をするための
  練習になったと思う。
