--------------------------

学籍番号 : 1613354
氏名 : 星野シンジ

--------------------------

回答1.2 : イベントハンドラを登録したオブジェクトは次のとおり

sceneにイベントハンドラを登録した。

イベントハンドラを上のように登録した理由は以下のとおり

マウスでCalculatorの画面のどこかを押すと、フォーカスがその押した座標に基づいて、
sceneの子ノードのどれかに移ってしまう。フォーカスの移動により、キーボード入力が
処理されない等の問題が発生しないように、OSでCalculatorが最前ウィンドウになって
いる限りは、ちゃんとキーボード入力がイベントとして拾われるようにするために、scene
にイベントハンドラを登録した。

回答4 : package para.graphic.parserの動作の説明

Main02でまず、MainParser()のインスタンスを作成し、図形を描く先のTargetと図形の
id管理をするShapeManager()を引数として渡す。
ここで、MainParser()の役割は、与えられたデータの頭見ることによって次に何のデータが来るかを
判定し、適切なParserを呼び出すことである。
例で与えられたdataの場合、MainParser()がshapeを見た時点で、ShapeManagerParser()を呼び出し、
図形の識別子を解釈させ、それがShapeManager()で管理される。次に、Circleを見た時点で、
CircleParser()が呼び出され、円を描くために必要なデータの解釈がされる。ここで、CircleParser()
が円の描かれる位置のデータが解釈された後に、Attributeのデータを解釈して、Attributeクラスの
データを生成するために、Attributeを見た時点でAttributeParser()が呼び出されて、
Attributeのデータが解釈される。ここまでの時点で、Circleクラスの新たなオブジェクトが
作られ、ShapeManager()が管理している状態になっている。
さらにdetaの次の行で、MainParser()がtargetを見た時点でTargetParser()が呼び出され、
TargetParser()はTargetクラスのオブジェクトの適切なメソッドを呼び出す。ここでは、
drawとなっているので、Targetのdraw()というメソッドが呼び出され、ShapeManager()ないで
管理されている図形が全て画面に描かれる。
最後にdataの最後の行で、MainParser()がtargetを読み込み、先ほどと同じようにTargetParser()
を呼び出す。TargetParser()はflushを解釈して、Targetのflushメソッドを呼び出す。

このような仕組みで、parserが他のparserを呼び出すことによって、複数のパターンがある
データに柔軟に対応ができる仕組みになっている。

例えば、CircleのデータをParseするときとTriangleのデータをParseするときでは引数の数が
異なるが、別々のParserを呼び出すようになっているために、拡張するのが容易になっている。

if-else文を並べた実装方法と比べた拡張性に関する利点はつぎのとおり

前の問題の最後の方で少し触れたが、上の実装方だとParserが図形ごとに別々に実装されており、
必要に応じて別々に呼ばれるようになっているため、新しい図形を追加するときに、書き換えを
する必要がなく、新しいクラスとメソッドをいくつか追加するだけで済む。

しかし一方で、if-else文を用いると上で実装したものを一つのParserで実装することと同じになり
拡張する際に、引数の数などが変わるとコードを大きく書き換える必要が出る。この点に関しては、
実装の仕方次第で避けられる場合もあるが、if-else文だけだとコードが複雑になりすぎる為に、
実現が上の方法に比べて難しい。また、この実装方法だとwhile文の中に巨大なif-else文を
書くことになり、長くて複雑な文章を解釈することになると、探索木のような処理をしている
上の実装に比べて、処理速度の面で不利になる可能性が大きい。

回答5 : para.graphic.parserパッケージの各クラスのアクセス修飾を次のようにした
AttributeParser       public -> 無修飾
CircleParser          public -> 無修飾　　
ImageParser           public -> 無修飾　　
MainParser            public -> public
MetaParser            public -> 無修飾
RectangleParser       public -> 無修飾
ShapeManagerParser    public -> 無修飾
ShapeParser           public -> 無修飾
TargetParser          public -> 無修飾

上記のようにアクセス修飾をした理由は次のとおり

MainParser以外のクラスは、MainParserから直接または間接的に呼び出されて動作をする
Parserであり、package外部クラスから呼ばれると、プログラマーが意図しない結果になってしまう
可能性が高い。従って、そもそも最初からpackage外から呼び出せないようにするべきである。
以上の理由で、データを解釈を開始するのに必要なMainParser以外のクラスは、全て同一パッケージ内
のみからのアクセスが可能になるようにアクセス修飾を設定した。

回答6 : para.graphic.parser.ImageParserの仕組みの説明

まず、最初の二つの数字で画像の大きさを取得し、最後の画像出力に用いる為に取っておく。
次に、処理できる最大の画像が入るほどの大きさがあるByteの配列を用意する。それを用意した上で
それ以降の文字列を全てバイトシーケンスに変換し、順にByteの配列にコピーしていく。文字列"&"が
終了を意味し、それがきたら文字列の読み込みを終了する。
最後に、Base64.wrap()を用いて、エンコードされたバイトストリームをデコードするための入力ストリームを
用意し、画像変換を行なって、それを結果としてBufferedImageとして取り出す。そして、それをImageに変換して、
返り値として返すという仕組みになっている。

工夫した点や感想：
