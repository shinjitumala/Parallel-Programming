--------------------------

学籍番号 : 1613354
氏名 : 星野シンジ

--------------------------

回答1 :
1.1) OrderedShapeManagerの実装についての説明
利用したクラスについてや、最小限の実装行で済ませる工夫などを説明して下さい。

この実装においては、AbstractCollectionを継承しているTreeSetを用いた。
TreeSetクラスを用いた理由は、addされた要素を自動的にソートするからである。
また、TreeSetクラスは同期化されていないが、ShapeManagerクラスでモニタを行なっている
ので、複数のアクセスが同時に来ることはない。

OrderedShapeManagerの親クラスであるShapeManagerのコンストラクターで
ShapeManager(AbstractCollection<Shape> data)を呼び出せば、super()を
呼ぶ時にdataを好きに初期化できる。これを利用することによって、実装は10数行ですんだ。

1.2)
空欄Aに入る語は：カプセル化
空欄Bに入る語は：モニタ

回答２ :
2.1) para.Main05のメンバ変数valueに直接関連した処理を行うスレッド名と
その役割はそれぞれ次のとおり

スレッド名   |　役割
---------------------------------

Thread-4                  valueの値を取得し、その値でモグラの絵を更新する
JavaFX Application Thread スライダーの値に変更があると、valueにsliderの値を再代入する

2.2)
ユーザ視点でのプログラムの不具合

スライダーの値が適用されない場合がある。このプログラムでは、
スライダーと値の変更とモグラのサイズの変化との間に遅延が生じることがある。

不具合の原因についての講義で説明されたプログラムを処理する仕組みに基づいた説明

volatileをつけないと最適化器が誤った判断を下して、作業用コピーの存在のために、
処理に矛盾が生じてしまう場合がある。

回答3 :
3.1)
配布されたpara.Main06による仕様のように動かない挙動の説明

このプログラムが意図しているのは、２種類のカウンターを同時に走らせることである。
よって、その二つのカウンターをそれぞれ独立して動かすためには、それぞれがデータを
共有しない必要がある。

オリジナルのMain06では二つのカウンターで別々のShapeManagerが必要であるが、
設定が同じであるために、"sm2 = sm1"という行で同じもののコピーを作ろうとしている。
ここで、"sm2 = sm1"というのは、Shallowコピーを行なってしまっており、sm1とsm2が両方
同じオブジェクトを指す変数名になってしまっている。このことにより、Runnerクラスの二つのインスタンス
ts1とts2によってShapeManagerが共有されてしまい、両方から１つのShapeManager
に対し、カウンターの表示するべき図形の更新が行われている。

したがって、incrementとdecrementのカウンターが両方同じ値を示し、かつその値が
incrementとdecrementの値でチラチラするという現象が起きる。

これは、ts1とts2で別々のShapeManagerのインスタンスを渡してあげれば直せる。
つまり、"sm2 = sm1"の行を"sm2 = sm1.duplicate()"に入れ替えれば良い。

3.2)
つぎのどちらかの行を消して回答せよ
メソッドduplicate()は deep copy である。

スレッドセーフであると考える場合、その理由の説明

Runnerクラス２つのインスタンスのスレッドが存在する。
"sm2 = sm1"を"sm2 = sm1.duplicate()"に入れ替える
ことにより、この二つのスレッド間では共有する変数はShapeManagerのdataがポインタで指している
16個のCircleクラスのオブジェクト以外なくなる。

sm1とsm2ではShapeクラスのオブジェクトのポインタを持っているので、duplicateメソッドにより、
はじめにsm１にputsされた１６のCircleはsm1とsm2の両方からポインタで指されている。しかし、Shapeクラスのオブジェクトは
一度newすると中身を変更できないようになっているので、共有だが不可変である。

従って、このプログラムはマルチスレッドで並列計算をしても安全である。

スレッドセーフでないと考える場合、ソースコード修正部分とその説明

回答4 :
4.1)
２つのスレッド
１つ目のスレッドとその役割は次のとおり

Game01クラスのメンバとして定義されているthread

このスレッドの役割は、一定時間ごとにゲームの情報を更新し、また
画面を今のゲームの状態に基づいて再描画することである。


２つ目のスレッドとその役割は次のとおり

JavaFX Application Thread

ゲームのマウスクリック等の入力を処理する。

4.2)
para.game.GameFrameのメンバ変数xyについてsynchronizedメソッドによる同
期を行わなかった場合に生じる不正確なデータの処理の例は次のとおり

読み込みと書き込みが同時に起こったりすると、プログラムが誤った値を用いて
モグラ叩きのハンマーの位置を処理し間違える場合がある。

volatile修飾では不十分であることの理由

SynchronizedPointないで点のx、y座標と時間は３つで一つのセットのデータである。
従って、volatileだけをx, y, timeにつけてしまうと、SynchronizedPointのデータ
を取得するcopyメソッドが動いている途中に割り込みが生じ、セットではないデータが返り値
として返されることがある。このことにより、ゲーム内で意図しない動作が起きる可能性がある。

4.3)
para.game.GameFrameのメンバ変数leftonやrightonにvolatile修飾を付けるこ
とでマルチスレッドに対応できることの説明

SynchronizedPointとは違い、他のデータとセットとして扱われるものではなく、単独に
変化する状態値であるので、volatileを用いれば、値の書き込みと読み出しの途中で
割り込まれることがないので、それで十分である。

4.4)
ゲーム性を高めるために行った実装についての説明
得点ルールとその計算法の実装

モグラを殺すと100点もらえる。
モグラを速く殺すとそのぶんだけボーナスがもらえる。(０点から５０点)
ハンマーで空気を叩いたら-200点。

得点を表示するために行った実装

画面の下半分では、スコアが5けたで表示されており、毎サイクル更新して表示されている。
これのために、別でスコア表示のためにShapeManagerオブジェクトを作成した。

課題3で表示される図形を利用するための実装

Game01クラス内のmole()メソッドでCircleオブジェクトでShapeManagerに円を描いていたところ
をGardenクラスのsetMoleとremoveMoleを用いてモグラを描いた。

ゲームの終了条件を定めるための実装

モグラを５匹殺しそこねるとゲームオーバー。
ゲームが無限に続かないために、時間が経つとだんだんと難しくなる。

4.5)
更なるゲーム性の向上のための追加実装についての説明

ゲームが美しくなるように、背景を作った。

マウスクリックをした時に、スコアの変更が画面に見えるようにするために、
モグラを殺したら、緑色の数字でもらえた点数がマウスの近くに現れるようにした。
また、ハンマーを外すと同じように赤の数字で点数の変化が現れる。
これには、ismのShapeManagerを用いた。
また、逃してもいい残りのモグラの数も同じように表示されている。これは、スコア表示と
同じShapeManagerに登録されている。

工夫した点や感想：
