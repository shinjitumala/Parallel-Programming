--------------------------

学籍番号 : 1613354
氏名 : 星野　シンジ

--------------------------

回答1.2 : Buttonクラスの継承関係は次のとおり

java.lang.Object
  javafx.scene.Node
    javafx.scene.Parent
      javafx.scene.layout.Region
        javafx.scene.control.Control
          javafx.scene.control.Labeled
            javafx.scene.control.ButtonBase
              javafx.scene.control.Button

回答1.3 : setOnAction メソッドが定義されているクラスは次のとおり

クラスButtonBase

回答1.4 : handle メソッドが呼ばれる時の引数のクラス含まれている情報は次のとおり

Eventを継承するクラスのオブジェクトを含んでいる。つまり、発生したイベントについて
の情報が含まれている。

回答2.1 : 作成されたclassファイルのディレクトリ位置はそれぞれ次のとおり

bin/para/paint/
bin/para/calc

回答2.2 : 説明は次のとおり

コンパイル時(javac)の-dオプションによってコンパイルしたクラスは、bin以下
のフォルダに入る。binのフォルダ内では、パッケージ名に基づいて、コンパイルされた
クラスファイルのおかれる場所が決まる。よって、para.paint.Paintという
ファイルをコンパイルすると、bin/para/paintにPaint.classというファイルが
作成される。

回答2.3 : 説明は次のとおり

javac、javaでコンパイル、実行する時に、-classpathオプションで指定された
ディレクトリに依存関係のあるクラスがおかれている必要がある。

回答3.1 : ソースコードの変更を次のように行った

まず、line_colorというdouble型の３要素の配列を用意し、赤緑青の値をそれぞれ格納した。
その上で、赤青緑のそれぞれのスライダーにリスナーを付け、それぞれのスライダーの値が
変更された場合は、line_colorの値を変更する。その後線の色を更新するメソッドUpdateLineProperties()
を呼び出し、線の色の更新の作業をそこで全てまとめて行うように書き換えた。

ここで、line_colorという配列を用いた理由としては、各スライダーのリスナーで
他のスライダーの値を取得するために不要なgetValue()による呼び出しを減らすためである。

回答3.2 : ソースコードの変更を次のように行った

新たに、line_propertyというdouble型の２要素の配列を用意し、線の不透明度、太さをそれぞれ格納した。
回答3.1と同じように新しいスライダーについてもリスナーをつけた。その後、UpdateLineProperties()
のメソッドの内容に、線の不透明度及び線の太さの更新の処理も追加した。

回答3.3 : ソースコードの変更を次のように行った

clearボタンをHBoxに入れることにより、新たに追加する正方形と横に並ぶように変更した。
それで、新たに作成したHBoxはclearボタンがもともと入っていたVBoxに追加した。
さらに、clearボタンのHBoxに新しいCanvasの挿入を行なった。
ここで、新しいCanvasの色がスライダーの操作によって変更されるように、赤青緑及び不透明度の
スライダーのリスナーに新たに正方形の色の更新を行うコードをそれぞれ追加した。

回答3.4 : 機能拡張を次のように行った

追加機能その1　回転機能
　具体的な実装の説明

  回転機能を追加した。"clear"ボタンの下に"L Rotate"及び"R Rotate"のボタンを追加した。
  その後、RotateCanvas(int i) (int i は回転の角度)というメソッドを実装し、"Rotate"のボタンが押された時に、
  適切にRotateを呼び出すようにイベントハンドラを設定した。

  RotateCanvas()メソッドの中身の説明をする。まず、canvasの現在の状態をImageとして、Canvas.snapshot()
  を用いて一旦保存する。そして、canvasを白にリセットした後に、保存されたImageをi度回転させて、元の
  canvasに描画するという処理となっている。

追加機能その2　スタンプ機能
　具体的な実装の説明

  スタンプ機能を追加した。回転機能のボタンの下に新しいHBoxを用意し、ボタンを追加した。これらのボタンは、
  int型のmouse_statusという変数の中身を変え、マウスイベントのハンドラが、mouse_statusの値によって
  動作が変わるという仕組みで、スタンプ機能を実装した。

  マウスは、線を描く時にも使うので、それを切り替えるボタンを追加するという形でスタンプ機能を追加した。
  それぞれのスタンプについて、与えられた座標を中心にそれぞれの図形を描くメソッドを用意し、マウスクリックの
  イベントハンドラでswitch文で場合分けをして、切り替えを実装した。
  マウスドラッグのイベントハンドラ内は、mouse_statusが線を引くモードの時のみ動作をするようにした。

回答4.1 :
　実装に工夫した点があれば説明

  ボタンの大きさが揃うようにButton.setPrefHeight/Width()メソッドを用いて、綺麗に見えるようにした。

回答4.2 :
  (イベントハンドラの登録の実装をどう行ったかを説明
  工夫した点があれば、その説明)

  "="と"<"以外のボタンでは、そのボタンの名前がそのまま入力の内容になるので、それらのボタンでは全て同じ
  イベントハンドラをつけた。イベントハンドラ内では、イベントソースのボタンの名前を取得し、
  それをStringBuilder buffにアペンドした後に、buffをLabel inputに表示するという内容になっている。
  イベントハンドラ内の一連の処理は、AppendLabelInput()メソッドを呼び出して行われている。
  このように実装することによって、イベントハンドラを１６個作ることを避けられた。

  また、"<"ボタンが押された時は、DeleteLabelInput()メソッドが呼び出されるように
  イベントハンドラを設定した。DeleteLabelInput()メソッドではbuffの末尾を一文字削除した後、
  その内容をinputに表示している。

回答4.3 :
  "="ボタンが押されると、CallCalculator()メソッドが呼び出されるようにイベント
  ハンドラを設定した。CallCalculator()メソッドでは引数で渡されたStringをそのまま
  Executorクラスのインスタンスexにoperationメソッドの引数として渡した。その返り値は、
  Label outputのテキストとして設定し、GUIに表示した。
